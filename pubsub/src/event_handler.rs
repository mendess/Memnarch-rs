use std::collections::HashMap;

use crate::publish_with;

use super::{events, publish};
use serenity::{
    client::{bridge::gateway::event::ShardStageUpdateEvent, Context, EventHandler},
    json::Value,
    model::{
        application::{command::CommandPermission, interaction::Interaction},
        channel::{Channel, ChannelCategory, GuildChannel, PartialGuildChannel, StageInstance},
        channel::{Message, Reaction},
        event::{
            ChannelPinsUpdateEvent, GuildMembersChunkEvent, GuildScheduledEventUserAddEvent,
            GuildScheduledEventUserRemoveEvent, InviteCreateEvent, InviteDeleteEvent,
            MessageUpdateEvent, ResumedEvent, ThreadListSyncEvent, ThreadMembersUpdateEvent,
            TypingStartEvent, VoiceServerUpdateEvent,
        },
        gateway::Presence,
        gateway::Ready,
        guild::{
            automod::{ActionExecution, Rule},
            Emoji, Guild, Integration, Member, PartialGuild, Role, ScheduledEvent, ThreadMember,
            UnavailableGuild,
        },
        id::{ChannelId, EmojiId, GuildId, MessageId, RoleId, StickerId, UserId},
        prelude::{ApplicationId, IntegrationId},
        sticker::Sticker,
        user::{CurrentUser, User},
        voice::VoiceState,
    },
};

#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Handler(Option<UserId>);

impl Handler {
    /// The bot_id, if passed, will serve to filter a few events that are generated by bot actions
    /// such as new messages and reactions.
    pub fn new<I: Into<Option<UserId>>>(bot_id: I) -> Self {
        Self(bot_id.into())
    }
}

#[serenity::async_trait]
impl EventHandler for Handler {
    async fn application_command_permissions_update(
        &self,
        ctx: Context,
        permission: CommandPermission,
    ) {
        publish::<events::ApplicationCommandPermissionUpdate>(ctx, permission).await;
    }

    async fn auto_moderation_rule_create(&self, ctx: Context, rule: Rule) {
        publish::<events::AutoModerationRuleCreate>(ctx, rule).await;
    }

    async fn auto_moderation_rule_update(&self, ctx: Context, rule: Rule) {
        publish::<events::AutoModerationRuleUpdate>(ctx, rule).await;
    }

    async fn auto_moderation_rule_delete(&self, ctx: Context, rule: Rule) {
        publish::<events::AutoModerationRuleDelete>(ctx, rule).await;
    }

    async fn auto_moderation_action_execution(&self, ctx: Context, execution: ActionExecution) {
        publish::<events::AutoModerationActionExecution>(ctx, execution).await;
    }

    async fn cache_ready(&self, ctx: Context, guilds: Vec<GuildId>) {
        publish::<events::CacheReady>(ctx, guilds).await;
    }

    async fn channel_create(&self, ctx: Context, channel: &GuildChannel) {
        publish_with::<events::ChannelCreate>(ctx, || channel.clone()).await
    }

    async fn category_create(&self, ctx: Context, category: &ChannelCategory) {
        publish_with::<events::CategoryCreate>(ctx, || category.clone()).await
    }

    async fn category_delete(&self, ctx: Context, category: &ChannelCategory) {
        publish_with::<events::CategoryDelete>(ctx, || category.clone()).await;
    }

    async fn channel_delete(&self, ctx: Context, channel: &GuildChannel) {
        publish_with::<events::ChannelDelete>(ctx, || channel.clone()).await;
    }

    async fn channel_pins_update(&self, ctx: Context, pin: ChannelPinsUpdateEvent) {
        publish::<events::ChannelPinsUpdate>(ctx, pin).await;
    }

    async fn channel_update(&self, ctx: Context, old: Option<Channel>, new: Channel) {
        publish::<events::ChannelUpdate>(ctx, events::ChannelUpdate { old, new }).await;
    }

    async fn guild_ban_addition(&self, ctx: Context, guild_id: GuildId, banned_user: User) {
        publish::<events::GuildBanAddition>(
            ctx,
            events::GuildBanAddition {
                guild_id,
                banned_user,
            },
        )
        .await;
    }

    async fn guild_ban_removal(&self, ctx: Context, guild_id: GuildId, unbanned_user: User) {
        publish::<events::GuildBanRemoval>(
            ctx,
            events::GuildBanRemoval {
                guild_id,
                unbanned_user,
            },
        )
        .await;
    }

    async fn guild_create(&self, ctx: Context, guild: Guild, is_new: bool) {
        publish::<events::GuildCreate>(ctx, events::GuildCreate { guild, is_new }).await;
    }

    async fn guild_delete(&self, ctx: Context, incomplete: UnavailableGuild, full: Option<Guild>) {
        publish::<events::GuildDelete>(ctx, events::GuildDelete { incomplete, full }).await;
    }

    async fn guild_emojis_update(
        &self,
        ctx: Context,
        guild_id: GuildId,
        current_state: HashMap<EmojiId, Emoji>,
    ) {
        publish::<events::GuildEmojisUpdate>(
            ctx,
            events::GuildEmojisUpdate {
                guild_id,
                current_state,
            },
        )
        .await;
    }

    async fn guild_integrations_update(&self, ctx: Context, guild_id: GuildId) {
        publish::<events::GuildIntegrationsUpdate>(ctx, guild_id).await;
    }

    async fn guild_member_addition(&self, ctx: Context, new_member: Member) {
        publish::<events::GuildMemberAddition>(ctx, new_member).await;
    }

    async fn guild_member_removal(
        &self,
        ctx: Context,
        guild_id: GuildId,
        user: User,
        member_data_if_available: Option<Member>,
    ) {
        publish::<events::GuildMemberRemoval>(
            ctx,
            events::GuildMemberRemoval {
                guild_id,
                user,
                member_data_if_available,
            },
        )
        .await;
    }

    async fn guild_member_update(
        &self,
        ctx: Context,
        old_if_available: Option<Member>,
        new: Member,
    ) {
        publish::<events::GuildMemberUpdate>(
            ctx,
            events::GuildMemberUpdate {
                old_if_available,
                new,
            },
        )
        .await;
    }

    async fn guild_members_chunk(&self, ctx: Context, chunk: GuildMembersChunkEvent) {
        publish::<events::GuildMembersChunk>(ctx, chunk).await;
    }

    async fn guild_role_create(&self, ctx: Context, new: Role) {
        publish::<events::GuildRoleCreate>(ctx, new).await;
    }

    async fn guild_role_delete(
        &self,
        ctx: Context,
        guild_id: GuildId,
        removed_role_id: RoleId,
        removed_role_data_if_available: Option<Role>,
    ) {
        publish::<events::GuildRoleDelete>(
            ctx,
            events::GuildRoleDelete {
                guild_id,
                removed_role_id,
                removed_role_data_if_available,
            },
        )
        .await;
    }

    async fn guild_role_update(
        &self,
        ctx: Context,
        old_data_if_available: Option<Role>,
        new: Role,
    ) {
        publish::<events::GuildRoleUpdate>(
            ctx,
            events::GuildRoleUpdate {
                old_data_if_available,
                new,
            },
        )
        .await;
    }

    async fn guild_stickers_update(
        &self,
        ctx: Context,
        guild_id: GuildId,
        current_state: HashMap<StickerId, Sticker>,
    ) {
        publish::<events::GuildStickersUpdate>(
            ctx,
            events::GuildStickersUpdate {
                guild_id,
                current_state,
            },
        )
        .await;
    }

    async fn guild_unavailable(&self, ctx: Context, guild_id: GuildId) {
        publish::<events::GuildUnavailable>(ctx, guild_id).await;
    }

    async fn guild_update(
        &self,
        ctx: Context,
        old_data_if_available: Option<Guild>,
        new_but_incomplete: PartialGuild,
    ) {
        publish::<events::GuildUpdate>(
            ctx,
            events::GuildUpdate {
                old_data_if_available,
                new_but_incomplete,
            },
        )
        .await;
    }

    async fn invite_create(&self, ctx: Context, data: InviteCreateEvent) {
        if data.inviter.as_ref().map(|u| u.id) != self.0 {
            publish::<events::InviteCreate>(ctx, data).await;
        }
    }

    async fn invite_delete(&self, ctx: Context, data: InviteDeleteEvent) {
        publish::<events::InviteDelete>(ctx, data).await;
    }

    async fn message(&self, ctx: Context, new_message: Message) {
        if Some(new_message.author.id) != self.0 {
            publish::<events::Message>(ctx, new_message).await;
        }
    }

    async fn message_delete(
        &self,
        ctx: Context,
        channel_id: ChannelId,
        deleted_message_id: MessageId,
        guild_id: Option<GuildId>,
    ) {
        publish::<events::MessageDelete>(
            ctx,
            events::MessageDelete {
                channel_id,
                deleted_message_id,
                guild_id,
            },
        )
        .await;
    }

    async fn message_delete_bulk(
        &self,
        ctx: Context,
        channel_id: ChannelId,
        multiple_deleted_messages_ids: Vec<MessageId>,
        guild_id: Option<GuildId>,
    ) {
        publish::<events::MessageDeleteBulk>(
            ctx,
            events::MessageDeleteBulk {
                channel_id,
                multiple_deleted_messages_ids,
                guild_id,
            },
        )
        .await;
    }

    async fn message_update(
        &self,
        ctx: Context,
        old_if_available: Option<Message>,
        new: Option<Message>,
        event: MessageUpdateEvent,
    ) {
        if event.author.as_ref().map(|u| u.id) != self.0 {
            publish::<events::MessageUpdate>(
                ctx,
                events::MessageUpdate {
                    old_if_available,
                    new,
                    event,
                },
            )
            .await;
        }
    }

    async fn reaction_add(&self, ctx: Context, add_reaction: Reaction) {
        if add_reaction.user_id != self.0 {
            publish::<events::ReactionAdd>(ctx, add_reaction).await;
        }
    }

    async fn reaction_remove(&self, ctx: Context, remove_reaction: Reaction) {
        if remove_reaction.user_id != self.0 {
            publish::<events::ReactionRemove>(ctx, remove_reaction).await;
        }
    }

    async fn reaction_remove_all(
        &self,
        ctx: Context,
        channel_id: ChannelId,
        removed_from_message_id: MessageId,
    ) {
        publish::<events::ReactionRemoveAll>(
            ctx,
            events::ReactionRemoveAll {
                channel_id,
                removed_from_message_id,
            },
        )
        .await;
    }

    async fn presence_replace(&self, ctx: Context, presence: Vec<Presence>) {
        publish::<events::PresenceReplace>(ctx, presence).await;
    }

    async fn presence_update(&self, ctx: Context, new_data: Presence) {
        publish::<events::PresenceUpdate>(ctx, new_data).await;
    }

    async fn ready(&self, ctx: Context, ready: Ready) {
        publish::<events::Ready>(ctx, ready).await;
    }

    async fn resume(&self, ctx: Context, event: ResumedEvent) {
        publish::<events::Resume>(ctx, event).await;
    }

    async fn shard_stage_update(&self, ctx: Context, event: ShardStageUpdateEvent) {
        publish::<events::ShardStageUpdate>(ctx, event).await;
    }

    async fn typing_start(&self, ctx: Context, event: TypingStartEvent) {
        publish::<events::TypingStart>(ctx, event).await;
    }

    async fn unknown(&self, ctx: Context, name: String, raw: Value) {
        publish::<events::Unknwon>(ctx, events::Unknwon { name, raw }).await;
    }

    async fn user_update(&self, ctx: Context, old_data: CurrentUser, new: CurrentUser) {
        publish::<events::UserUpdate>(ctx, events::UserUpdate { old_data, new }).await
    }

    async fn voice_server_update(&self, ctx: Context, event: VoiceServerUpdateEvent) {
        publish::<events::VoiceServerUpdate>(ctx, event).await;
    }

    async fn voice_state_update(&self, ctx: Context, old: Option<VoiceState>, new: VoiceState) {
        publish::<events::VoiceStateUpdate>(ctx, events::VoiceStateUpdate { new, old }).await;
    }

    async fn webhook_update(
        &self,
        ctx: Context,
        guild_id: GuildId,
        belongs_to_channel_id: ChannelId,
    ) {
        publish::<events::WebhookUpdate>(
            ctx,
            events::WebhookUpdate {
                guild_id,
                belongs_to_channel_id,
            },
        )
        .await;
    }

    async fn interaction_create(&self, ctx: Context, interaction: Interaction) {
        publish::<events::InteractionCreate>(ctx, interaction).await;
    }

    async fn integration_create(&self, ctx: Context, integration: Integration) {
        publish::<events::IntegrationCreate>(ctx, integration).await;
    }

    async fn integration_update(&self, ctx: Context, integration: Integration) {
        publish::<events::IntegrationUpdate>(ctx, integration).await;
    }

    async fn integration_delete(
        &self,
        ctx: Context,
        integration_id: IntegrationId,
        guild_id: GuildId,
        application_id: Option<ApplicationId>,
    ) {
        publish::<events::IntegrationDelete>(
            ctx,
            events::IntegrationDelete {
                integration_id,
                guild_id,
                application_id,
            },
        )
        .await;
    }

    async fn stage_instance_create(&self, ctx: Context, stage_instance: StageInstance) {
        publish::<events::StageInstanceCreate>(ctx, stage_instance).await;
    }

    async fn stage_instance_update(&self, ctx: Context, stage_instance: StageInstance) {
        publish::<events::StageInstanceUpdate>(ctx, stage_instance).await;
    }

    async fn stage_instance_delete(&self, ctx: Context, stage_instance: StageInstance) {
        publish::<events::StageInstanceDelete>(ctx, stage_instance).await;
    }

    async fn thread_create(&self, ctx: Context, thread: GuildChannel) {
        publish::<events::ThreadCreate>(ctx, thread).await;
    }

    async fn thread_update(&self, ctx: Context, thread: GuildChannel) {
        publish::<events::ThreadUpdate>(ctx, thread).await;
    }

    async fn thread_delete(&self, ctx: Context, thread: PartialGuildChannel) {
        publish::<events::ThreadDelete>(ctx, thread).await
    }

    async fn thread_list_sync(&self, ctx: Context, thread_list_sync: ThreadListSyncEvent) {
        publish::<events::ThreadListSync>(ctx, thread_list_sync).await
    }

    async fn thread_member_update(&self, ctx: Context, thread_member: ThreadMember) {
        publish::<events::ThreadMemberUpdate>(ctx, thread_member).await
    }

    async fn thread_members_update(
        &self,
        ctx: Context,
        thread_members_update: ThreadMembersUpdateEvent,
    ) {
        publish::<events::ThreadMembersUpdate>(ctx, thread_members_update).await
    }

    async fn guild_scheduled_event_create(&self, ctx: Context, event: ScheduledEvent) {
        publish::<events::GuildScheduledEventCreate>(ctx, event).await
    }

    async fn guild_scheduled_event_update(&self, ctx: Context, event: ScheduledEvent) {
        publish::<events::GuildScheduledEventUpdate>(ctx, event).await
    }

    async fn guild_scheduled_event_delete(&self, ctx: Context, event: ScheduledEvent) {
        publish::<events::GuildScheduledEventDelete>(ctx, event).await
    }

    async fn guild_scheduled_event_user_add(
        &self,
        ctx: Context,
        subscribed: GuildScheduledEventUserAddEvent,
    ) {
        publish::<events::GuildScheduledEventUserAdd>(ctx, subscribed).await
    }

    async fn guild_scheduled_event_user_remove(
        &self,
        ctx: Context,
        unsubscribed: GuildScheduledEventUserRemoveEvent,
    ) {
        publish::<events::GuildScheduledEventUserRemove>(ctx, unsubscribed).await
    }
}
