use super::{events, publish};
use futures::stream::{self, StreamExt};
use serenity::{
    model::{
        channel::Reaction,
        gateway::Ready,
        guild::Guild,
        id::{ChannelId, GuildId, MessageId},
        prelude::{interaction::Interaction, UserId},
        voice::VoiceState,
    },
    prelude::*,
};
use std::mem::take;

/// The event handler you can register with serenity to have the events be published through the
/// [subscribe](super::subscribe) function.
pub struct Handler(Option<UserId>);

impl Handler {
    /// Create a new handler.
    ///
    /// bot_id: Optionally pass the bot's id to filter out events generated by the bot itself.
    pub fn new<I: Into<Option<UserId>>>(bot_id: I) -> Self {
        Self(bot_id.into())
    }
}

#[serenity::async_trait]
impl EventHandler for Handler {
    async fn voice_state_update(&self, ctx: Context, old: Option<VoiceState>, new: VoiceState) {
        // Disconnect channel of mirrodin
        if let (Some(gid @ GuildId(352399774818762759)), Some(id @ ChannelId(707561909846802462))) =
            (new.guild_id, new.channel_id)
        {
            async fn f(id: ChannelId, gid: GuildId, ctx: &Context) -> anyhow::Result<()> {
                let c = id.to_channel(ctx).await.and_then(|c| {
                    c.guild()
                        .ok_or(serenity::Error::Other("Not a guild channel"))
                })?;
                let members = c.members(ctx).await?;
                stream::iter(members)
                    .for_each(|mut m| async move {
                        let name = take(&mut m.user.name);
                        if let Err(e) = gid.disconnect_member(ctx, m).await {
                            log::error!(
                                "Failed to disconnect member {} from disconnect channel: {}",
                                name,
                                e
                            );
                        }
                    })
                    .await;
                Ok(())
            }
            if let Err(e) = f(id, gid, &ctx).await {
                log::error!("Failed to disconnect user: {}", e);
            }
        }
        publish::<events::VoiceStateUpdate>(ctx, (new.guild_id, old, new));
    }

    async fn reaction_add(&self, ctx: Context, add_reaction: Reaction) {
        if add_reaction.user_id != self.0 {
            publish::<events::ReactionAdd>(ctx, add_reaction);
        }
    }

    async fn reaction_remove(&self, ctx: Context, remove_reaction: Reaction) {
        if remove_reaction.user_id != self.0 {
            publish::<events::ReactionRemove>(ctx, remove_reaction);
        }
    }

    async fn reaction_remove_all(&self, ctx: Context, channel_id: ChannelId, msg: MessageId) {
        publish::<events::ReactionRemoveAll>(ctx, (channel_id, msg));
    }

    async fn cache_ready(&self, ctx: Context, guilds: Vec<GuildId>) {
        publish::<events::CacheReady>(ctx, guilds);
    }

    async fn ready(&self, ctx: Context, ready: Ready) {
        publish::<events::Ready>(ctx, ready);
    }

    async fn guild_create(&self, ctx: Context, guild: Guild, is_new: bool) {
        log::info!("found guild {}::{}", guild.name, guild.id);
        publish::<events::GuildCreate>(ctx, (guild, is_new));
    }

    async fn interaction_create(&self, ctx: Context, interaction: Interaction) {
        publish::<events::InteractionCreate>(ctx, interaction);
    }
}
